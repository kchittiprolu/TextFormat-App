using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using log4net;
using Palmmedia.ReportGenerator.Analysis;
using Palmmedia.ReportGenerator.Parser;
using Palmmedia.ReportGenerator.Reporting;

namespace Palmmedia.ReportGenerator
{
    /// <summary>
    /// Converts a coverage report generated by PartCover, OpenCover or NCover into a readable report.
    /// In contrast to the XSLT-Transformation included in PartCover, the report is more detailed.
    /// It does not only show the coverage quota, but also includes the source code and visualizes which line has been covered.
    /// </summary>
    public class ReportBuilder
    {
        /// <summary>
        /// The logger.
        /// </summary>
        private static readonly ILog logger = LogManager.GetLogger(typeof(ReportBuilder));

        /// <summary>
        /// The parser to use.
        /// </summary>
        private readonly IParser parser;

        /// <summary>
        /// The renderer factory to use.
        /// </summary>
        private readonly IRendererFactory rendererFactory;

        /// <summary>
        /// The directory where the generated report should be saved.
        /// </summary>
        private readonly string targetDirectory;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReportBuilder"/> class.
        /// </summary>
        /// <param name="parser">The IParser to use.</param>
        /// <param name="rendererFactory">The renderer factory.</param>
        /// <param name="targetDirectory">The directory where the generated report should be saved.</param>
        public ReportBuilder(IParser parser, IRendererFactory rendererFactory, string targetDirectory)
        {
            if (parser == null)
            {
                throw new ArgumentNullException("parser");
            }

            if (rendererFactory == null)
            {
                throw new ArgumentNullException("rendererFactory");
            }

            if (targetDirectory == null)
            {
                throw new ArgumentNullException("targetDirectory");
            }

            this.parser = parser;
            this.rendererFactory = rendererFactory;
            this.targetDirectory = targetDirectory;
        }

        /// <summary>
        /// Starts the generation of the report.
        /// </summary>
        public void CreateReport()
        {
            int numberOfClasses = 0;
            var assemblies = new List<Assembly>();

            foreach (var assemblyName in this.parser.Assemblies())
            {
                var assembly = new Assembly(assemblyName);
                var classes = this.parser.ClassesInAssembly(assemblyName);

                foreach (var className in classes)
                {
                    var clazz = new Class(assembly.Name, className);
                    assembly.AddClass(clazz);
                    numberOfClasses++;
                }

                assemblies.Add(assembly);
            }

            logger.InfoFormat("Analyzing {0} classes", numberOfClasses);

            int counter = 0;

            if (this.rendererFactory.SupportsParallelClassReports)
            {
                Parallel.ForEach(
                    assemblies,
                    (assembly) =>
                    {
                        Parallel.ForEach(
                            assembly.Classes,
                            (clazz) =>
                            {
                                int current = Interlocked.Increment(ref counter);

                                logger.InfoFormat(
                                    CultureInfo.InvariantCulture,
                                    " Creating report {0}/{1} (Assembly: {2}, Class: {3})",
                                    current,
                                    numberOfClasses,
                                    clazz.AssemblyName,
                                    clazz.Name);

                                this.CreateClassReport(clazz);
                            });
                    });
            }
            else
            {
                foreach (var assembly in assemblies)
                {
                    foreach (var clazz in assembly.Classes)
                    {
                        logger.DebugFormat(
                            CultureInfo.InvariantCulture,
                            " Creating report {0}/{1} (Assembly: {2}, Class: {3})",
                            ++counter,
                            numberOfClasses,
                            clazz.AssemblyName,
                            clazz.Name);

                        this.CreateClassReport(clazz);
                    }
                }
            }

            this.CreateSummary(assemblies);
        }

        /// <summary>
        /// Creates the summary showing a overview of all assemblies and classes.
        /// </summary>
        /// <param name="assemblies">The assemblies.</param>
        private void CreateSummary(IEnumerable<Assembly> assemblies)
        {
            logger.Info("Creating summary");

            int coveredLines = assemblies.Sum(a => a.CoveredLines);
            int coverableLines = assemblies.Sum(a => a.CoverableLines);
            decimal coverage = coverableLines == 0 ? 0 : (decimal)Math.Truncate(1000 * (double)coveredLines / (double)coverableLines) / 10;

            var summaryRenderer = this.rendererFactory.CreateSummaryRenderer();

            if (summaryRenderer == null)
            {
                return;
            }

            summaryRenderer.BeginSummaryReport("Summary");
            summaryRenderer.Header("Summary");

            summaryRenderer.BeginKeyValueTable();
            summaryRenderer.KeyValueRow("Generated on:", DateTime.Now.ToShortDateString() + " - " + DateTime.Now.ToLongTimeString());
            summaryRenderer.KeyValueRow("Parser:", this.parser.ToString());
            summaryRenderer.KeyValueRow("Assemblies:", assemblies.Count().ToString(CultureInfo.InvariantCulture));
            summaryRenderer.KeyValueRow("Files:", this.parser.Files().Count().ToString(CultureInfo.InvariantCulture));
            summaryRenderer.KeyValueRow("Coverage:", coverage.ToString(CultureInfo.InvariantCulture) + "%");
            summaryRenderer.KeyValueRow("Covered lines:", coveredLines.ToString(CultureInfo.InvariantCulture));
            summaryRenderer.KeyValueRow("Coverable lines:", coverableLines.ToString(CultureInfo.InvariantCulture));
            summaryRenderer.KeyValueRow("Total lines:", assemblies.Sum(a => a.TotalLines).ToString(CultureInfo.InvariantCulture));
            summaryRenderer.FinishTable();

            summaryRenderer.Header("Assemblies");

            if (assemblies.Any())
            {
                summaryRenderer.BeginSummaryTable();

                foreach (var assembly in assemblies)
                {
                    summaryRenderer.SummaryAssembly(assembly);

                    foreach (var clazz in assembly.Classes)
                    {
                        summaryRenderer.SummaryClass(clazz);
                    }
                }

                summaryRenderer.FinishTable();
            }
            else
            {
                summaryRenderer.Paragraph("No assemblies have been covered.");
            }

            summaryRenderer.SaveSummaryReport(this.targetDirectory);
        }

        /// <summary>
        /// Creates the report for the given class.
        /// </summary>
        /// <param name="clazz">The class.</param>
        private void CreateClassReport(Class clazz)
        {
            var files = this.parser.FilesOfClass(clazz.AssemblyName, clazz.Name);

            var fileAnalysis = files.Select(f => this.AnalyzeFile(f, clazz)).ToArray();

            if (!fileAnalysis.Any())
            {
                clazz.CoverageQuota = this.parser.GetCoverageQuotaOfClass(clazz.AssemblyName, clazz.Name);
                clazz.CoverageType = CoverageType.MethodCoverage;
            }

            var classRenderer = this.rendererFactory.CreateClassRenderer();

            if (classRenderer == null)
            {
                return;
            }

            classRenderer.BeginClassReport(clazz.Name);

            classRenderer.Header("Summary");

            classRenderer.BeginKeyValueTable();
            classRenderer.KeyValueRow("Class:", clazz.Name);
            classRenderer.KeyValueRow("Assembly:", clazz.ShortAssemblyName);
            classRenderer.KeyValueRow("File(s):", files);
            classRenderer.KeyValueRow("Coverage:", clazz.CoverageQuota.ToString(CultureInfo.InvariantCulture) + "%");
            classRenderer.KeyValueRow("Covered lines:", clazz.CoveredLines.ToString(CultureInfo.InvariantCulture));
            classRenderer.KeyValueRow("Coverable lines:", clazz.CoverableLines.ToString(CultureInfo.InvariantCulture));
            classRenderer.KeyValueRow("Total lines:", clazz.TotalLines.ToString(CultureInfo.InvariantCulture));
            classRenderer.FinishTable();

            var metrics = this.parser.MethodMetrics(clazz.AssemblyName, clazz.Name);

            if (metrics != null && metrics.Any())
            {
                classRenderer.Header("Metrics");

                classRenderer.BeginMetricsTable(new[] { "Method" }.Union(metrics.First().Metrics.Select(m => m.Name)));

                foreach (var metric in metrics)
                {
                    classRenderer.MetricsRow(metric);
                }

                classRenderer.FinishTable();
            }

            classRenderer.Header("File(s)");

            if (fileAnalysis.Any())
            {
                foreach (var file in fileAnalysis)
                {
                    classRenderer.File(file.FileName);

                    if (!string.IsNullOrEmpty(file.Error))
                    {
                        classRenderer.Paragraph(file.Error);
                    }
                    else
                    {
                        classRenderer.BeginLineAnalysisTable(new[] { string.Empty, "#", "Line", "Coverage" });

                        foreach (var line in file.Lines)
                        {
                            classRenderer.LineAnalysis(line);
                        }

                        classRenderer.FinishTable();
                    }
                }
            }
            else
            {
                classRenderer.Paragraph("No files found. This usually happens if a file isn't covered by a test or the class does not contain any sequence points (e.g. a class that only contains auto properties).");
            }

            classRenderer.SaveClassReport(this.targetDirectory, clazz.ShortAssemblyName, clazz.Name);
        }

        /// <summary>
        /// Analyses a file and generates a coverage report of the file.
        /// </summary>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="clazz">The name of the assembly.</param>
        /// <returns>The generated coverage report of the given file.</returns>
        private FileAnalysis AnalyzeFile(string fileName, Class clazz)
        {
            if (!File.Exists(fileName))
            {
                string error = string.Format(CultureInfo.InvariantCulture, "File '{0}' does not exist (any more).", fileName);
                logger.Error(error);
                return new FileAnalysis(fileName, error);
            }

            try
            {
                string[] lines = File.ReadAllLines(fileName);

                clazz.TotalLines += lines.Length;

                int currentLineNumber = 0;

                var result = new FileAnalysis(fileName);

                foreach (var line in lines)
                {
                    int visits = this.parser.NumberOfLineVisits(clazz.AssemblyName, clazz.Name, fileName, ++currentLineNumber);

                    if (visits == 0)
                    {
                        clazz.CoverableLines++;
                    }
                    else if (visits > 0)
                    {
                        clazz.CoveredLines++;
                        clazz.CoverableLines++;
                    }

                    result.AddLineAnalysis(new LineAnalysis(visits, currentLineNumber, line.TrimEnd()));
                }

                return result;
            }
            catch (IOException ex)
            {
                string error = string.Format(CultureInfo.InvariantCulture, "Error during reading file '{0}': {1}", fileName, ex.Message);
                logger.Error(error);
                return new FileAnalysis(fileName, error);
            }
        }
    }
}