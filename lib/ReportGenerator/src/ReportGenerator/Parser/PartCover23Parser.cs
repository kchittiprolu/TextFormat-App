using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Xml.Linq;
using log4net;
using Palmmedia.ReportGenerator.Common;
using Palmmedia.ReportGenerator.Parser.CodeAnalysis;

namespace Palmmedia.ReportGenerator.Parser
{
    /// <summary>
    /// Parser for XML reports generated by PartCover 2.3 and above.
    /// </summary>
    public class PartCover23Parser : ParserBase, IParser
    {
        /// <summary>
        /// The logger.
        /// </summary>
        private static readonly ILog logger = LogManager.GetLogger(typeof(PartCover23Parser));

        /// <summary>
        /// Dictionary containing the assembly names by id.
        /// In PartCover 2.3.0.35109 the assemblies are referenced by an id.
        /// Before only their name was required.
        /// </summary>
        private Dictionary<string, string> assembliesByIdDictionary;

        /// <summary>
        /// The attribute name to the corresponding assembly.
        /// In PartCover 2.3.0.35109 this is "asmref".
        /// </summary>
        private string assemblyAttribute = "asm";

        /// <summary>
        /// Initializes a new instance of the <see cref="PartCover23Parser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        public PartCover23Parser(XContainer report)
            : base(report)
        {
            bool lastestPartCoverVersion = false;

            // Determine which version of PartCover 2.3 has been used.
            // In PartCover 2.3.0.35109 the assemblies are referenced by an id and the attribute name in Type elements has changed.
            var assemblies = report.Descendants("Assembly");
            if (assemblies.Any() && assemblies.First().Attribute("id") != null)
            {
                this.assemblyAttribute = "asmref";
                this.assembliesByIdDictionary = assemblies.ToDictionary(a => a.Attribute("id").Value, a => a.Attribute("name").Value);
                lastestPartCoverVersion = true;
            }
            else
            {
                this.assembliesByIdDictionary = assemblies.ToDictionary(a => a.Attribute("name").Value, a => a.Attribute("name").Value);
            }

            var fileIdByFilenameDictionary = report.Descendants("File").ToDictionary(f => f.Attribute("url").Value, f => f.Attribute("id").Value);

            if (lastestPartCoverVersion)
            {
                AddCoverageDataOfUnexecutedMethods(report);
            }

            AddCoverageDataOfAutoProperties(report);

            // Init the Dictionary containing the line coverage information
            Parallel.ForEach(
                this.Assemblies(),
                assembly =>
                {
                    logger.DebugFormat("  Current Assembly: {0}", assembly);

                    Parallel.ForEach(
                        this.ClassesInAssembly(assembly),
                        clazz =>
                        {
                            Parallel.ForEach(
                                this.FilesOfClass(assembly, clazz),
                                file =>
                                {
                                    string fileId = fileIdByFilenameDictionary[file];

                                    var seqpntsOfFile = report.Descendants("Type")
                                        .Where(type => this.assembliesByIdDictionary[type.Attribute(this.assemblyAttribute).Value].Equals(assembly) && type.Attribute("name").Value.StartsWith(clazz, StringComparison.Ordinal))
                                        .Descendants("pt")
                                        .Where(seqpnt => seqpnt.HasAttributeWithValue("fid", fileId))
                                        .OrderBy(seqpnt => int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture))
                                        .ToArray();

                                    if (seqpntsOfFile.Length > 0)
                                    {
                                        var coverage = new int[int.Parse(seqpntsOfFile.Last().Attribute("sl").Value, CultureInfo.InvariantCulture) + 1];

                                        for (int i = 0; i < coverage.Length; i++)
                                        {
                                            coverage[i] = -1;
                                        }

                                        foreach (var seqpnt in seqpntsOfFile)
                                        {
                                            var index = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture);
                                            var value = int.Parse(seqpnt.Attribute("visit").Value, CultureInfo.InvariantCulture);
                                            coverage[index] = coverage[index] == -1 ? value : coverage[index] + value;
                                        }

                                        this.LineCoverageByFileDictionary.TryAdd(assembly + "_" + clazz + "_" + file, coverage);
                                    }
                                });
                        });
                });
        }

        /// <summary>
        /// Determine all covered files.
        /// </summary>
        /// <returns>All covered files.</returns>
        public IEnumerable<string> Files()
        {
            return this.Report.Descendants("File")
                .Select(f => f.Attribute("url").Value)
                .ToArray();
        }

        /// <summary>
        /// Determine all covered assemblies.
        /// </summary>
        /// <returns>All covered assemblies.</returns>
        public IEnumerable<string> Assemblies()
        {
            return this.assembliesByIdDictionary.Values
                .OrderBy(value => value)
                .Distinct()
                .ToArray();
        }

        /// <summary>
        /// Determine all covered classes within an assembly.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>All covered classes within an assembly.</returns>
        public IEnumerable<string> ClassesInAssembly(string assemblyName)
        {
            if (!this.assembliesByIdDictionary.ContainsValue(assemblyName))
            {
                return new string[] { };
            }

            return this.Report.Descendants("Type")
                .Where(type => this.assembliesByIdDictionary[type.Attribute(this.assemblyAttribute).Value].Equals(assemblyName) && !type.Attribute("name").Value.Contains("__"))
                .Select(type => type.Attribute("name").Value)
                .OrderBy(name => name)
                .Distinct()
                .ToArray();
        }

        /// <summary>
        /// Determine all files a class is defined in.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <param name="className">The name of the class.</param>
        /// <returns>All files a class is defined in.</returns>
        public IEnumerable<string> FilesOfClass(string assemblyName, string className)
        {
            if (!this.assembliesByIdDictionary.ContainsValue(assemblyName))
            {
                return new string[] { };
            }

            var fileIds = this.Report.Descendants("Type")
                .Where(type => this.assembliesByIdDictionary[type.Attribute(this.assemblyAttribute).Value].Equals(assemblyName) && type.Attribute("name").Value.Equals(className))
                .Elements("Method")
                .Elements("pt")
                .Where(pt => pt.Attribute("fid") != null)
                .Select(pt => pt.Attribute("fid").Value)
                .Distinct().ToHashSet();

            return this.Report.Descendants("File").
                Where(file => fileIds.Contains(file.Attribute("id").Value))
                .Select(file => file.Attribute("url").Value)
                .ToArray();
        }

        /// <summary>
        /// Determine how often a line of code has been covered.
        /// If line could not be covered at all -1 is returned.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <param name="className">The name of the class.</param>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="lineNumber">The number of the line (starting with 1, not zero based).</param>
        /// <returns>Number of visits.</returns>
        public int NumberOfLineVisits(string assemblyName, string className, string fileName, int lineNumber)
        {
            if (!this.assembliesByIdDictionary.ContainsValue(assemblyName))
            {
                return -1;
            }

            var key = assemblyName + "_" + className + "_" + fileName;
            if (this.LineCoverageByFileDictionary.ContainsKey(key))
            {
                var coverage = this.LineCoverageByFileDictionary[key];
                return (coverage.Length > lineNumber) ? coverage[lineNumber] : -1;
            }
            else
            {
                return -1;
            }
        }

        /// <summary>
        /// Adds the coverage data of unexecuted methods.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        private static void AddCoverageDataOfUnexecutedMethods(XContainer report)
        {
            var unexecutedMethods = report.Descendants("Method").Where(m => !m.Elements().Any());

            var filenameByFileIdDictionary = report.Descendants("File").ToDictionary(f => f.Attribute("id").Value, f => f.Attribute("url").Value);

            foreach (var method in unexecutedMethods)
            {
                PartCoverMethodElement partCoverMethodElement = new PartCoverMethodElement(
                    method.Parent.Attribute("name").Value,
                    method.Attribute("name").Value,
                    method.Attribute("sig").Value);

                // Get files in which method could be defined
                var fileIds = method.Parent.Descendants("pt").Where(p => p.Attribute("fid") != null).Select(p => p.Attribute("fid").Value).Distinct();

                foreach (var file in fileIds)
                {
                    var elementPosition = SourceCodeAnalyzer.FindSourceElement(filenameByFileIdDictionary[file], partCoverMethodElement);

                    if (elementPosition == null)
                    {
                        continue;
                    }

                    for (int i = elementPosition.Start; i <= elementPosition.End; i++)
                    {
                        var seqpnt = new XElement(
                            "pt",
                            new XAttribute("visit", "0"),
                            new XAttribute("fid", file),
                            new XAttribute("sl", i));

                        method.Add(seqpnt);
                    }

                    break;
                }
            }
        }

        /// <summary>
        /// Adds the coverage data of auto properties.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        private static void AddCoverageDataOfAutoProperties(XContainer report)
        {
            Func<string, bool> isProperty = v => v.StartsWith("get_", StringComparison.Ordinal) || v.StartsWith("set_", StringComparison.Ordinal);

            var unexecutedProperties = report.Descendants("Method").Where(m => isProperty(m.Attribute("name").Value)
                && (!m.Elements().Any() || !m.Elements().Any(pt => pt.Attribute("sl") != null)));

            var filenameByFileIdDictionary = report.Descendants("File").ToDictionary(f => f.Attribute("id").Value, f => f.Attribute("url").Value);

            foreach (var property in unexecutedProperties)
            {
                PropertyElement propertyElement = new PropertyElement(property.Attribute("name").Value);

                // Get files in which method could be defined
                var fileIds = property.Parent.Descendants("pt").Where(p => p.Attribute("fid") != null).Select(p => p.Attribute("fid").Value).Distinct();

                foreach (var file in fileIds)
                {
                    var elementPosition = SourceCodeAnalyzer.FindSourceElement(filenameByFileIdDictionary[file], propertyElement);

                    if (elementPosition == null)
                    {
                        continue;
                    }

                    if (!property.Elements().Any())
                    {
                        var seqpnt = new XElement(
                            "pt",
                            new XAttribute("visit", "0"),
                            new XAttribute("fid", file),
                            new XAttribute("sl", elementPosition.Start));

                        property.Add(seqpnt);
                    }
                    else
                    {
                        foreach (var pt in property.Elements().Take(1))
                        {
                            pt.Add(new XAttribute("sl", elementPosition.Start));
                            pt.Add(new XAttribute("fid", file));
                        }
                    }

                    break;
                }
            }
        }
    }
}
