using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using log4net;
using Palmmedia.ReportGenerator.Common;
using Palmmedia.ReportGenerator.Parser.CodeAnalysis;

namespace Palmmedia.ReportGenerator.Parser
{
    /// <summary>
    /// Parser for XML reports generated by OpenCover.
    /// </summary>
    public class OpenCoverParser : ParserBase, IParser
    {
        /// <summary>
        /// Regex to analyze/split a methode name.
        /// </summary>
        private const string MethodRegex = @"^.*::(?<MethodName>.+)\((?<Arguments>.*)\)$";

        /// <summary>
        /// The logger.
        /// </summary>
        private static readonly ILog logger = LogManager.GetLogger(typeof(OpenCoverParser));

        /// <summary>
        /// The covered assemblies. The HashSet is used for caching.
        /// </summary>
        private HashSet<string> assembliesHashSet;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenCoverParser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        public OpenCoverParser(XContainer report)
            : base(report)
        {
            // Init the HashSet containing the covered assemblies
            this.assembliesHashSet = new HashSet<string>(
                report.Descendants("Module")
                .Where(m => m.Attribute("skippedDueTo") == null)
                .Select(m => m.Element("ModuleName").Value)
                .Distinct());

            AddCoverageDataOfAutoProperties(report);

            // Init the Dictionary containing the line coverage information
            Parallel.ForEach(
                this.Assemblies(),
                assembly =>
                {
                    logger.DebugFormat("  Current Assembly: {0}", assembly);

                    var fileIdsByFilenameDictionary = report.Descendants("Module")
                        .Where(m => m.Element("ModuleName").Value.Equals(assembly))
                        .Descendants("File")
                        .GroupBy(f => f.Attribute("fullPath").Value, f => f.Attribute("uid").Value)
                        .ToDictionary(g => g.Key, g => g.ToHashSet());

                    Parallel.ForEach(
                        this.ClassesInAssembly(assembly),
                        clazz =>
                        {
                            var methodMetrics = new List<MethodMetric>();

                            foreach (var file in this.FilesOfClass(assembly, clazz))
                            {
                                HashSet<string> fileIds = fileIdsByFilenameDictionary[file];

                                var methods = this.Report.Descendants("Module")
                                    .Where(m => m.Element("ModuleName").Value.Equals(assembly))
                                    .Elements("Classes")
                                    .Elements("Class")
                                    .Where(c => c.Element("FullName").Value.StartsWith(clazz, StringComparison.Ordinal))
                                    .Elements("Methods")
                                    .Elements("Method")
                                    .Where(m => m.Element("FileRef") != null && fileIds.Contains(m.Element("FileRef").Attribute("uid").Value))
                                    .ToArray();

                                SetMethodMetrics(methods, methodMetrics);

                                var seqpntsOfFile = methods.Descendants("SequencePoint")
                                    .Select(seqpnt => new
                                    {
                                        LineNumber = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture),
                                        Visits = int.Parse(seqpnt.Attribute("vc").Value, CultureInfo.InvariantCulture)
                                    })
                                    .OrderBy(seqpnt => seqpnt.LineNumber)
                                    .ToArray();

                                if (seqpntsOfFile.Length > 0)
                                {
                                    var coverage = new int[seqpntsOfFile[seqpntsOfFile.LongLength - 1].LineNumber + 1];

                                    for (int i = 0; i < coverage.Length; i++)
                                    {
                                        coverage[i] = -1;
                                    }

                                    foreach (var seqpnt in seqpntsOfFile)
                                    {
                                        coverage[seqpnt.LineNumber] = coverage[seqpnt.LineNumber] == -1 ? seqpnt.Visits : coverage[seqpnt.LineNumber] + seqpnt.Visits;
                                    }

                                    this.LineCoverageByFileDictionary.TryAdd(assembly + "_" + clazz + "_" + file, coverage);
                                }
                            }

                            this.MethodMetricsByClass.TryAdd(assembly + "_" + clazz, methodMetrics);
                        });
                });
        }

        /// <summary>
        /// Determine all covered files.
        /// </summary>
        /// <returns>All covered files.</returns>
        public IEnumerable<string> Files()
        {
            return this.Report.Descendants("File")
                .Select(f => f.Attribute("fullPath").Value)
                .Distinct()
                .ToArray();
        }

        /// <summary>
        /// Determine all covered assemblies.
        /// </summary>
        /// <returns>All covered assemblies.</returns>
        public IEnumerable<string> Assemblies()
        {
            return this.assembliesHashSet
                .OrderBy(value => value)
                .ToArray();
        }

        /// <summary>
        /// Determine all covered classes within an assembly.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <returns>All covered classes within an assembly.</returns>
        public IEnumerable<string> ClassesInAssembly(string assemblyName)
        {
            if (!this.assembliesHashSet.Contains(assemblyName))
            {
                return new string[] { };
            }

            return this.Report.Descendants("Module")
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => !c.Element("FullName").Value.Contains("__")
                    && !c.Element("FullName").Value.Contains("<")
                    && !c.Element("FullName").Value.Contains("/")
                    && c.Attribute("skippedDueTo") == null)
                .Select(c => c.Element("FullName").Value)
                .Distinct()
                .OrderBy(name => name)
                .ToArray();
        }

        /// <summary>
        /// Determine all files a class is defined in.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <param name="className">The name of the class.</param>
        /// <returns>All files a class is defined in.</returns>
        public IEnumerable<string> FilesOfClass(string assemblyName, string className)
        {
            if (!this.assembliesHashSet.Contains(assemblyName))
            {
                return new string[] { };
            }

            var fileIds = this.Report.Descendants("Module")
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.Equals(className))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Element("FileRef") != null)
                .Select(m => m.Element("FileRef").Attribute("uid").Value)
                .Distinct()
                .ToHashSet();

            return this.Report.Descendants("File")
                .Where(file => fileIds.Contains(file.Attribute("uid").Value))
                .Select(file => file.Attribute("fullPath").Value)
                .Distinct()
                .ToArray();
        }

        /// <summary>
        /// Determine how often a line of code has been covered.
        /// If line could not be covered at all -1 is returned.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <param name="className">The name of the class.</param>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="lineNumber">The number of the line (starting with 1, not zero based).</param>
        /// <returns>Number of visits.</returns>
        public int NumberOfLineVisits(string assemblyName, string className, string fileName, int lineNumber)
        {
            if (!this.assembliesHashSet.Contains(assemblyName))
            {
                return -1;
            }

            var key = assemblyName + "_" + className + "_" + fileName;
            if (this.LineCoverageByFileDictionary.ContainsKey(key))
            {
                var coverage = this.LineCoverageByFileDictionary[key];
                return (coverage.Length > lineNumber) ? coverage[lineNumber] : -1;
            }
            else
            {
                return -1;
            }
        }

        /// <summary>
        /// Gets the coverage quota of a class.
        /// This method is used to get coverage quota if line coverage is not available.
        /// </summary>
        /// <param name="assemblyName">The name of the assembly.</param>
        /// <param name="className">The name of the class.</param>
        /// <returns>The coverage quota.</returns>
        public override decimal GetCoverageQuotaOfClass(string assemblyName, string className)
        {
            var methodGroups = this.Report.Descendants("Module")
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.StartsWith(className, StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Attribute("skippedDueTo") == null && m.Element("FileRef") == null)
                .GroupBy(m => m.Element("Name").Value)
                .ToArray();

            int visitedMethods = methodGroups.Count(g => g.Any(m => m.Attribute("visited").Value == "true"));

            return (methodGroups.Length == 0) ? 0 : (decimal)Math.Truncate(1000 * (double)visitedMethods / (double)methodGroups.Length) / 10;
        }

        /// <summary>
        /// Adds the coverage data of auto properties.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        private static void AddCoverageDataOfAutoProperties(XContainer report)
        {
            Func<XElement, bool> isProperty = v => v.HasAttributeWithValue("isGetter", "true") || v.HasAttributeWithValue("isSetter", "true");

            var unexecutedProperties = report.Descendants("Module")
                                    .Elements("Classes")
                                    .Elements("Class")
                                    .Elements("Methods")
                                    .Elements("Method")
                                    .Where(m => m.Attribute("skippedDueTo") == null
                                        && isProperty(m)
                                        && m.Element("SequencePoints") != null
                                        && !m.Element("SequencePoints").Elements().Any())
                                    .ToArray();

            foreach (var property in unexecutedProperties)
            {
                var filenameByFileIdDictionary = property.Parent.Parent.Parent.Parent
                    .Element("Files")
                    .Elements("File")
                    .ToDictionary(f => f.Attribute("uid").Value, f => f.Attribute("fullPath").Value);

                string methodName = Regex.Match(property.Element("Name").Value, MethodRegex).Groups["MethodName"].Value;
                PropertyElement openCoverProperty = new PropertyElement(methodName);

                // Get files in which property could be defined
                var fileIds = property.Parent.Elements("Method").Elements("FileRef").Select(f => f.Attribute("uid").Value).Distinct();

                foreach (var file in fileIds)
                {
                    var elementPosition = SourceCodeAnalyzer.FindSourceElement(filenameByFileIdDictionary[file], openCoverProperty);

                    if (elementPosition == null)
                    {
                        continue;
                    }

                    property.Add(new XElement("FileRef", new XAttribute("uid", file)));

                    var seqpnt = new XElement(
                        "SequencePoint",
                        new XAttribute("vc", property.Element("MethodPoint").Attribute("vc").Value),
                        new XAttribute("sl", elementPosition.Start));

                    property.Element("SequencePoints").Add(seqpnt);

                    break;
                }
            }
        }

        /// <summary>
        /// Extracts the metrics from the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="methods">The methods.</param>
        /// <param name="methodMetrics">The extracted method metrics.</param>
        private static void SetMethodMetrics(IEnumerable<XElement> methods, List<MethodMetric> methodMetrics)
        {
            foreach (var methodGroup in methods.GroupBy(m => m.Element("Name").Value))
            {
                var method = methodGroup.First();

                // Exclude properties and lambda expressions
                if (method.Attribute("skippedDueTo") != null
                    || method.HasAttributeWithValue("isGetter", "true")
                    || method.HasAttributeWithValue("isSetter", "true")
                    || Regex.IsMatch(methodGroup.Key, "::<.+>.+__"))
                {
                    continue;
                }

                string methodName = Regex.Replace(
                    methodGroup.Key,
                    MethodRegex,
                    m => string.Format(CultureInfo.InvariantCulture, "{0}({1})", m.Groups["MethodName"].Value, m.Groups["Arguments"].Value.Length > 0 ? "..." : string.Empty));

                var metrics = new[] 
                { 
                    new Metric(
                        "Cyclomatic Complexity", 
                        methodGroup.Max(m => int.Parse(m.Attribute("cyclomaticComplexity").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        "Sequence Coverage", 
                        methodGroup.Max(m => int.Parse(m.Attribute("sequenceCoverage").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        "Branch Coverage", 
                        methodGroup.Max(m => int.Parse(m.Attribute("branchCoverage").Value, CultureInfo.InvariantCulture)))
                };

                methodMetrics.Add(new MethodMetric(methodName, metrics));
            }
        }
    }
}
